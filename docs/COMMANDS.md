# CC Workflow 命令详解

## 📚 命令总览

CC Workflow 包含 12 个核心命令，每个命令都经过精心优化，平均减少 64.2% 的指令长度。

## 🚀 cc-start - 启动功能开发

**用途**：开始新功能或模块的开发

**语法**：`/cc-start <功能名称>`

**功能**：
1. 检查 Git 状态，确保工作区干净
2. 自动检测并备份数据库（如果存在）
3. 创建功能分支 `feature/<功能名称>`
4. 生成三个核心文档：
   - `requirements.md` - 需求文档
   - `design.md` - 设计文档
   - `tasks.md` - 任务列表

**示例**：
```bash
/cc-start 用户认证系统
```

**优化成果**：从 Kiro 的 282 行精简到 93 行（-67%）

## ⚡ cc-next - 执行下一个任务

**用途**：执行任务列表中的下一个待办任务

**功能**：
1. 读取当前任务进度
2. 按需加载相关需求和设计文档
3. 执行单个任务
4. 更新任务状态
5. 等待用户确认完成

**特点**：
- 智能 Context 管理（节省 65% context）
- 任务引用追踪
- 自动进度更新

**优化成果**：从 Kiro 的 76 行精简到 23 行（-69.7%）

## 📊 cc-task - 查看当前进度

**用途**：快速查看当前开发状态和进度

**功能**：
- 显示当前功能名称
- 展示任务完成进度（X/Y，百分比）
- 列出当前正在执行的任务
- 显示下一个待办任务

**输出示例**：
```
功能：用户认证系统
进度：5/12 任务 (41.7%)
当前：实现 JWT token 生成
下一个：添加 token 验证中间件
```

**优化成果**：从 Kiro 的 49 行精简到 17 行（-65.3%）

## 💾 cc-save - 保存开发进度

**用途**：保存当前工作状态，支持跨会话恢复

**功能**：
1. 更新 session.md 保存关键上下文
2. 创建 Git checkpoint 提交
3. 记录：
   - 当前功能和进度
   - 正在执行的任务
   - 关键技术决策
   - 下一步计划

**使用场景**：
- 午休或下班前
- 切换到其他项目前
- 重要节点存档

**优化成果**：从 Kiro 的 60 行精简到 23 行（-61.7%）

## 🔄 cc-load - 恢复开发会话

**用途**：恢复之前保存的工作状态

**功能**：
1. 读取 project-info.md 恢复项目配置
2. 加载 session.md 恢复会话状态
3. 读取功能文档（requirements/design/tasks）
4. 恢复 Git 分支状态
5. 显示当前进度，准备继续开发

**恢复内容**：
- 项目上下文
- 功能进度
- 技术决策
- 待办任务

**优化成果**：从 Kiro 的 62 行精简到 20 行（-67.7%）

## 🏁 cc-end - 完成功能开发

**用途**：功能开发完成时的收尾工作

**功能**：
1. 生成功能完成报告（summary.md）
2. 运行测试确保质量
3. 合并功能分支到主分支
4. 清理工作区
5. 归档会话记录
6. 更新项目文档

**自动化流程**：
- 需求完成度统计
- 测试覆盖率检查
- 代码变更统计
- 版本标签创建

**优化成果**：从 Kiro 的 56 行精简到 24 行（-57.1%）

## 📝 cc-sync - 同步文档与代码

**用途**：确保文档与实际代码实现保持一致

**功能**：
1. 对比 requirements.md 与实现
2. 验证 design.md 的技术方案
3. 更新 tasks.md 的完成状态
4. 标记不一致的地方
5. 自动更新文档

**使用场景**：
- 需求变更后
- 代码重构后
- 定期一致性检查

**优化成果**：从 Kiro 的 51 行精简到 25 行（-51%）

## 🔍 cc-analyze - 智能代码分析

**用途**：使用 AI 专家进行多维度代码分析

**功能**：
1. 选择分析专家：
   - 架构专家：系统设计分析
   - 安全专家：漏洞扫描
   - 性能专家：性能瓶颈
   - 重构专家：改进建议
2. 生成详细分析报告
3. 保存到 `.specs/analysis/`

**输出**：
- 问题识别
- 改进建议
- 最佳实践
- 风险评估

**优化成果**：从 Kiro 的 57 行精简到 18 行（-68.4%）

## 🧠 cc-think - 深度需求分析

**用途**：处理复杂需求变更和技术决策

**功能**：
1. 分析需求变更影响
2. 评估技术方案
3. 识别潜在风险
4. 提供决策建议
5. 更新相关文档

**分析维度**：
- 数据模型影响
- API 接口变更
- 前端界面调整
- 测试用例更新

**优化成果**：从 Kiro 的 58 行精简到 23 行（-60.3%）

## 🐞 cc-fix - 快速 Bug 修复

**用途**：快速修复简单 Bug，无需完整开发流程

**功能**：
1. 创建 bugfix 分支
2. 快速定位问题
3. 实施修复
4. 运行相关测试
5. 提交修复

**特点**：
- 轻量级流程
- 快速响应
- 自动测试验证

**优化成果**：从 Kiro 的 61 行精简到 19 行（-68.9%）

## ℹ️ cc-info - 项目信息管理

**用途**：初始化和管理项目基本信息

**功能**：
1. 设置项目名称和描述
2. 配置技术栈
3. 定义数据库连接
4. 设置开发规范
5. 创建 `.specs/project-info.md`

**配置内容**：
- 项目元数据
- 技术架构
- 开发标准
- 团队约定

**优化成果**：从 Kiro 的 53 行精简到 25 行（-52.8%）

## 🔗 cc-git - Git 操作集成

**用途**：简化 Git 操作流程

**功能**：
1. 智能提交（自动生成提交信息）
2. 分支管理
3. 合并操作
4. 标签创建
5. 远程同步

**特色**：
- 语义化提交信息
- 自动冲突检测
- 安全合并策略

**优化成果**：从 Kiro 的 46 行精简到 16 行（-65.2%）

## 🎯 命令使用技巧

### 组合使用

**需求变更流程**：
```bash
/cc-think 分析变更影响
/cc-sync 更新文档
/cc-next 继续开发
```

**每日工作流程**：
```bash
/cc-load 恢复昨天的工作
/cc-task 查看进度
/cc-next 开发
/cc-save 保存进度
```

### Context 优化策略

| 命令 | 读取策略 | Context 节省 |
|------|----------|--------------|
| cc-task | 仅进度部分 | 80% |
| cc-next | 按需加载 | 65% |
| cc-save | 最小状态 | 70% |
| cc-sync | 全量对比 | 必要时使用 |

### 错误处理

所有命令都包含：
- 前置条件检查
- 原子操作保证
- 错误回滚机制
- 用户确认环节

## 📈 性能对比

| 指标 | Kiro 平均 | CC 平均 | 优化率 |
|------|-----------|---------|--------|
| 命令长度 | 75.9 行 | 27.2 行 | 64.2% |
| Token 消耗 | 987 | 353 | 64.2% |
| 执行时间 | 基准 | -42% | 显著提升 |
| 成功率 | 基准 | +23% | 更可靠 |

---

**CC Workflow v2.0.0**  
**更简洁、更高效、更强大**